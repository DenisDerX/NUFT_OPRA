#include <iostream>
#include <fstream>
#include <conio.h>
#include <cstdio>
#include <cstring>
#include <windows.h>

using namespace std;
HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE); /* Отримання
дескриптора пристрою стандартного виводу, а саме консолі*/
//задаємо константи, що визначають довжину символьних полів: прізвище замовника, назва товару, назва доставки, дата доставки.
const int l_surname = 13, l_name = 18, l_delivery = 18, l_date = 10;
const int countZinP = 50; // оголошуємо константу, що регламентує кількість записів на екрані

//основна структура
struct iin
{
    char surname[l_surname];
    char date[l_date];
    char name[l_name];
    int nam;
    char delivery[l_delivery];
};

// глобальні змінні
fstream f; // файлова змінна
char fdir[100] = "1.txt"; // змінна для збереження повного імені файлу
void menu(); // попереднє оголошення процедури

// *** Процедура створення/відкриття файлу ***
void open_new()
{
    system("cls");
    printf(" Вкажіть повне ім'я файлу ( Приклад: \"С:\\Program Files\\file.dat\" ): ");
    cin >> fdir;
opf:
    f.open(fdir, ios::in | ios::out | ios::binary); // відкриваємо файл у бінарному режимі
    if (!f.is_open()) //якщо файл не відкрився
    {
        printf("\n\n Помилка при відкритті файлу, буде спроба його створити.\n\n\n ");
        ofstream ofs(fdir); //створюємо файл
        ofs.close(); //закриваємо потік створеного файлу
        printf(" Файл створено. \n\n ");
        goto opf;
    }
    else
        printf(" Файл відкрито для роботи. \n\n ");
    system("pause");
}

// *** Процедура додавання запису ***
void addzap()
{
    system("cls");
    int i, // змінна призначена для номера нового запису
        pp, // змінна для збереження натиснутої клавіші
        j, // змінна для збереження довжини символьних змінних
        t, // змінна для збереження довжини символьних змінних
        q1;
    iin prod; // оголошуємо змінну для роботи із записом
    f.clear(); // очищуємо прапорці помилок
    f.seekg(0, ios::end); // переводимо вказівник на кінець файлу
    i = f.tellp() / sizeof(struct iin); //визначаємо кількість записів 
s11:
    i++; //номер нового запису
    // обнулюяємо поля запису
    strcpy(prod.date, "");
    strcpy(prod.surname, "");
    strcpy(prod.name, "");
    prod.nam = 0;
    strcpy(prod.delivery, "");
    pp = 0;
    //далі заповнюємо поля нового запису
    cout << "Введіть замовлення № " << i << ": \n";

    cout << " Дата доставки -> ";
    do
    {
        gets_s(prod.date); // зчитуємо значення у символьне поле
        t = strlen(prod.date); //визначаємо довжину символьного поля
    } while (t == 0); // цикл буде виконуватися до тих пір, поки довжина введеного символьного поля буде нульовою
    for (j = t; j < l_date - 1; j++) // цикл забезпечує додавання до символьного поля пробілів до заданої довжини
        strcat(prod.date, " ");

    cout << "\n Прізвище замовника -> ";
    do
    {
        gets_s(prod.surname); // зчитуємо значення у символьне поле
        t = strlen(prod.surname); //визначаємо довжину символьного поля
    } while (t == 0); // цикл буде виконуватися до тих пір, поки довжина введеного символьного поля буде нульовою
    for (j = t; j < l_surname - 1; j++) // цикл забезпечує додавання до символьного поля пробілів до заданої довжини
        strcat(prod.surname, " ");

    cout << "\n Назва товару -> ";
    do
    {
        gets_s(prod.name); // зчитуємо значення у символьне поле
        t = strlen(prod.name); //визначаємо довжину символьного поля
    } while (t == 0); // цикл буде виконуватися до тих пір, поки довжина введеного символьного поля буде нульовою
    for (j = t; j < l_name - 1; j++) // цикл забезпечує додавання до символьного поля пробілів до заданої довжини
        strcat(prod.name, " ");

    cout << "\n Кількість товару -> ";
    do
    {
        cin >> prod.nam; // зчитуємо значення у числове поле
    } while (t == 0); // цикл буде виконуватися до тих пір, поки довжина введеного символьного поля буде нульовою

    cout << "\n Назва доставки -> ";
    do
    {
        gets_s(prod.delivery); // зчитуємо значення у символьне поле
        t = strlen(prod.delivery); //визначаємо довжину символьного поля
    } while (t == 0); // цикл буде виконуватися до тих пір, поки довжина введеного символьного поля буде нульовою
    for (j = t; j < l_delivery - 1; j++) // цикл забезпечує додавання до символьного поля пробілів до заданої довжини
        strcat(prod.delivery, " ");

    f.write((char*)&prod, sizeof(struct iin)); // записуємо у файл сформований запис
s12:
    cout << "Для введення ще одного запису натисніть -> Enter, для закінчення -> Esc \n";
    if ((pp = _getch()) != 27)
        if (pp == 13)
            goto s11;
        else
            goto s12;
}

// *** Процедура виведення усіх записів ***
void all_out()
{
    iin zap; // оголошуємо змінну для роботи із записом
    int space; // оголошуємо змінну, що є лічильником кількості записів на екрані
    int position = 0; // враховує к-сть виведених записів на сторінці
    int im = 0; // змінна для збереження коду натиснутої клавіші
    f.clear(); // очищуємо прапорці помилок
    f.seekp(0, ios::end); // переміщуємо вказівник на кінець файлу
    int size = f.tellp() / sizeof(struct iin); // визначаємо кількість записів у файлі
    if (size < 1)
    { // якщо записів немає, то дати повідомлення на екран
        cout << "Файл порожній";
        goto ex; // перехід на закінчення виконання процедури
    }

star:
    f.clear(); // очищуємо прапорці помилок
    f.seekp(position * countZinP * sizeof(struct iin), ios::beg); // переміщуємо вказівник на потрібний запис, що вираховується за наступною формулою
    position* countZinP * sizeof(struct iin);
    system("cls");
    printf("|<<< Загальна кількість записів у файлі = %5d >>>|\n", size);
    cout << ".___._______________.____________________._____________________.__________________.__________________.\n";
    cout << "| № | Дата доставки | Прізвище замовника |     Назва товару    | Кількість товару |  Назва доставки  |\n";
    cout << "|===|===============|====================|=====================|==================|==================|\n";
    space = 0; //обнуляємо значення лічильника кількості записів на екрані
    while ((!f.eof()) && (space < countZinP)) //умова виконання циклу: поки не досягли кінця файлу або кількість виведених записів на екран менше countZinP
    {
        f.read((char*)&zap, sizeof(struct iin)); //зчитування запису з файлу у змінну zap
        if (f.eof()) break; // якщо досягнуто кінець файлу, то вийти з циклу
        // виводимо поля зчитаного запису на екран
        printf("|%2d |  %.10s   | %13s      |  %17s  | %9d        | %14s|\n", ((1 + space) + ((position)*countZinP)), zap.date, zap.surname, zap.name, zap.nam, zap.delivery);
        space++; //збільшуємо лічильник кількості записів на екрані на 1
    }
    cout << "|___|_______________|____________________|_____________________|__________________|__________________|\n";
    printf("|<<<\"Up/Down - переміщення на стор.\"<<< №%2d >>>\"Esc -головне меню \">>>|\n", position + 1);
ctrl:
    im = _getch(); // зчитуємо код натиснутої клавіші
    switch (im)
    {
    case 80: // якщо натиснута клавіша "стрілка вниз" - Down
    {
        if (position < (size - 1) / countZinP)
            ++position;
        goto star; //повернення до мітки star:
    }
    case 72: // якщо натиснута клавіша "стрілка у гору" - Up
    {
        if (position >= 1)
            --position;
        goto star; //перехід до мітки star:
    }
    case 27:
        goto ex;
    default:
        goto ctrl;
    }
ex:;
}

// *** Процедура редагування запису ***
void editzap()
{
    int t, i=0, j, q1;
    int im; // змінна для збереження коду натиснутої клавіші
start:
    system("cls");
    iin zap; // оголошуємо змінну для роботи із записом
    int nom = 0; //номер запису для редагування
    cout << "Введіть номер запису, що буде відредаговано -> ";
    cin >> nom;
    f.clear();
    f.seekp((nom - 1) * sizeof(struct iin), ios::beg);//Переміщуємо вказівник на потрібний запис
    cout << ".___._______________.____________________._____________________.__________________.__________________.\n";
    cout << "| № | Дата доставки | Прізвище замовника |     Назва товару    | Кількість товару |  Назва доставки  |\n";
    cout << "|===|===============|====================|=====================|==================|==================|\n";
    f.read((char*)&zap, sizeof(struct iin));
    {
        printf("|   |  %.10s   | %13s      |  %17s  | %9d        | %14s|\n", zap.date, zap.surname, zap.name, zap.nam, zap.delivery);
    }
    cout << "|___|_______________|____________________|_____________________|__________________|__________________|\n";
    printf("|<<<<<<<\"Для підтвердження редагування натисніть Enter, а для відміни Esc\">>>>>>>|\n");
control:
    im = _getch(); // зчитуємо код натиснутої клавіші
    if (im == 13)
    {
        iin prod; // оголошуємо змінну для роботи із записом
        // обнулюяємо поля запису

        strcpy(prod.date, "");
        strcpy(prod.surname, "");
        strcpy(prod.name, "");
        prod.nam = 0;
        strcpy(prod.delivery, "");
        //далі заповнюємо поля нового запису
        cout << "Введіть замовлення № " << i << ": \n";

        cout << " Дата доставки -> ";
        do
        {
            gets_s(prod.date);
            t = strlen(prod.date);
        } while (t == 0);
        for (j = t; j < l_date - 1; j++)
            strcat(prod.date, " ");

        cout << "\n Прізвище замовника -> ";
        do
        {
            gets_s(prod.surname);
            t = strlen(prod.surname);
        } while (t == 0);
        for (j = t; j < l_surname - 1; j++)
            strcat(prod.surname, " ");

        cout << "\n Назва товару -> ";
        do
        {
            gets_s(prod.name);
            t = strlen(prod.name);
        } while (t == 0);
        for (j = t; j < l_name - 1; j++)
            strcat(prod.name, " ");

        cout << "\n Кількість товару -> ";
        do
        {
            cin >> prod.nam;
        } while (t == 0);

        cout << "\n Назва доставки -> ";
        do
        {
            gets_s(prod.delivery);
            t = strlen(prod.delivery);
        } while (t == 0);
        for (j = t; j < l_delivery - 1; j++)
            strcat(prod.delivery, " ");

        printf("|<<<<<<<\"Для підтвердження редагування натисніть Enter, а для відміни Esc\">>>>>>>|\n");
    control2:
        im = _getch(); // зчитуємо код натиснутої клавіші
        if (im == 13) // якщо натиснута клавіша Enter
        {
            f.seekp((nom - 1) * sizeof(struct iin), ios::beg); // переміщуємо вказівник на запис, що буде замінено
            f.write((char*)&prod, sizeof(struct iin)); // записуємо у файл новий запис
            goto start;
        }
        else
            if (im == 27) //якщо натиснута клавіша є Esc
                goto start;
        goto control2;
    }
    else
        if (im != 27) //якщо натиснута клавіша не є Esc
            goto control;
    system("pause");
}

// *** Процедура видалення запису ***
void delzap()
{
    system("cls");
    iin zap; // оголошуємо змінну для роботи із записом
    int im = 0; // змінна для збереження коду натиснутої клавіші
    int nom = 0; // змінна для номеру запису, що буде видалено з файлу
    cout << "Введіть номер запису, що буде видалено з файлу -> ";
    cin >> nom;
    f.clear(); // очищуємо прапорці помилок
    f.seekp((nom - 1) * sizeof(struct iin), ios::beg);//Переміщуємо вказівник на потрібний запис
    // виводимо поля запису на екран
    cout << " Цей запис буде видалено з файлу \n";
    cout << ".___._______________.____________________._____________________.__________________.__________________.\n";
    cout << "| № | Дата доставки | Прізвище замовника |     Назва товару    | Кількість товару |  Назва доставки  |\n";
    cout << "|===|===============|====================|=====================|==================|==================|\n";
    f.read((char*)&zap, sizeof(struct iin));
    printf("|   |  %.10s   | %13s      |  %17s  | %9d        | %14s|\n", zap.date, zap.surname, zap.name, zap.nam, zap.delivery);
    cout << "|___|_______________|____________________|_____________________|__________________|__________________|\n";
    printf("|<<<\"Для підтвердження редагування натисніть Enter, а для відміни Esc\">>>|\n");
control:
    im = _getch(); // зчитуємо код натиснутої клавіші
    if (im == 13) // якщо натиснута клавіша Enter
    {
        f.clear(); // очищуємо прапорці помилок
        f.seekp(0, ios::end); // переміщуємо вказівник на кінец файлу
        int size = f.tellp() / sizeof(struct iin); //визначаємо кількість записів у файлі
        iin* mas;
        mas = new iin[size + 1]; // виділяємо динамічну пам’ять під масив на кількість записів у файлі
        f.clear(); // очищуємо прапорці помилок
        f.seekp(0, ios::beg); // переміщуємо вказівник на початок у файлі
        int i = 0;
        while (!f.eof())
        {// зчитуємо у динамічний масив записів з файлу
            f.read((char*)&mas[i], sizeof(struct iin));
            i++;
        }
        f.close(); // закриваємо файл
        f.clear(); // очищуємо прапорці помилок
        f.open(fdir, ios::in | ios::out | ios::trunc); // відкриваємо файл та очищуємо його - знищуємо усі записи у файл
        f.seekp(0, ios::beg); // переміщуємо вказівник на початок файлу
        for (i = 0; i < size; i++) //цикл забезпечує запис усіх елементів масиву у файл
            if (i != (nom - 1)) // якщо поточний елемент не дорівнює заданому
                f.write((char*)&mas[i], sizeof(struct iin)); //запис поточного елементу у файл
        delete[]mas; // очищуємо виділену динамічну пам’ять під масив записів
        cout << "Запис видалено \n";
    }
    else
        if (im != 27) //якщо натиснута клавіша не є Esc
            goto control;
}

// *** Процедура завершення роботи програми ***
void exit_prog()
{
    system("cls");
    cout << "\n Натисніть: \n\n Enter для того, щоб вийти. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
st:
    int go = _getch(); //зчитуємо натиснуту клавішу
    if (go != 13) // перевірка чи не натиснута клавіша Enter
        if (go == 27) // перевірка чи натиснута клавіша Esc
            goto ex;
        else
            goto st; // буде здійснено перехід на мітку st, якщо буде натиснута клавіша відмінна від Enter та Esc
    if (f.is_open())
        f.close(); // закриваємо файл, якщо він був відкритий
    exit(0); // закриваємо програму / виходимо з неї
ex:;
}

// порівняння двох рядків
int fyy(char* a, char* b)
{
    int i = 0, j = strlen(a);
    while (j > i)
    {
        if (a[i] != b[i])
            return 0;
        i++;
    }
    return 1;
}

void intr1()
{
l1:
    system("cls");
    int y;
    cout << "Введіть кількість товару = ";
    cin >> y;
    iin zap; // оголошуємо змінну для роботи із записом
    int space; // оголошуємо змінну, що є лічильником кількості записів на екрані
    int position = 0; // враховує к-сть виведених записів на сторінці
    int im = 0; // змінна для збереження коду натиснутої клавіші
    f.clear(); // очищуємо прапорці помилок
    f.seekp(position * countZinP * sizeof(struct iin), ios::beg); // переміщуємо вказівник на потрібний запис, що вираховується за наступною формулою
    cout << ".___._______________.____________________._____________________.__________________.__________________.\n";
    cout << "| № | Дата доставки | Прізвище замовника |     Назва товару    | Кількість товару |  Назва доставки  |\n";
    cout << "|===|===============|====================|=====================|==================|==================|\n";
    space = 0; //обнуляємо значення лічильника кількості записів на екрані
    int a, b, c, a1, b1, c1;
    while ((!f.eof()) && (space < countZinP)) //умова виконання циклу: поки не досягли кінця файлу або кількість виведених записів на екран менше countZinP
    {
        f.read((char*)&zap, sizeof(struct iin)); //зчитування запису з файлу у змінну zap
        if (f.eof()) break; // якщо досягнуто кінець файлу, то вийти з циклу
        // виводимо поля зчитаного запису на екран
        if (zap.nam > y)
        {
            printf("|%2d |  %.10s   | %13s      |  %17s  | %9d        | %14s|\n", ((1 + space) + ((position)*countZinP)), zap.date, zap.surname, zap.name, zap.nam, zap.delivery);
        }
        space++;
    }
    cout << "|___|_______________|____________________|_____________________|__________________|__________________|\n";
    cout << "\n Натисніть: \n\n Enter для того, щоб зробить перевірку заново. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
l2:
    int go = _getch(); //зчитуємо натиснуту клавішу
    if (go == 13) // перевірка чи не натиснута клавіша Enter
    {
        goto l1;
    }
    if (go == 27) // перевірка чи натиснута клавіша Esc
    {
        goto ex;
    }
    else
    {
        goto l2;
    }
ex:
    system("pause");
}

void intr2()
{
l1:
    system("cls");
    char y[18] = "Експрес-доставка";
    iin zap; // оголошуємо змінну для роботи із записом
    int space; // оголошуємо змінну, що є лічильником кількості записів на екрані
    int position = 0; // враховує к-сть виведених записів на сторінці
    int im = 0; // змінна для збереження коду натиснутої клавіші
    f.clear(); // очищуємо прапорці помилок
    f.seekp(position * countZinP * sizeof(struct iin), ios::beg); // переміщуємо вказівник на потрібний запис, що вираховується за наступною формулою
    position* countZinP * sizeof(struct iin);
    cout << ".___._______________.____________________._____________________.__________________.__________________.\n";
    cout << "| № | Дата доставки | Прізвище замовника |     Назва товару    | Кількість товару |  Назва доставки  |\n";
    cout << "|===|===============|====================|=====================|==================|==================|\n";
    space = 0; //обнуляємо значення лічильника кількості записів на екрані
    int a, b, c, a1, b1, c1;
    while ((!f.eof()) && (space < countZinP)) //умова виконання циклу: поки не досягли кінця файлу або кількість виведених записів на екран менше countZinP
    {
        f.read((char*)&zap, sizeof(struct iin)); //зчитування запису з файлу у змінну zap
        if (f.eof()) break; // якщо досягнуто кінець файлу, то вийти з циклу
        // виводимо поля зчитаного запису на екран
        if (fyy(y, zap.delivery) == 1)
        {
            printf("|%2d |  %.10s   | %13s      |  %17s  | %9d        | %14s|\n", ((1 + space) + ((position)*countZinP)), zap.date, zap.surname, zap.name, zap.nam, zap.delivery);
        }
        space++;
    }
    cout << "|___|_______________|____________________|_____________________|__________________|__________________|\n";
    cout << "\n Натисніть: \n\n Enter для того, щоб зробить перевірку заново. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
    int go = _getch(); //зчитуємо натиснуту клавішу
    if (go == 13) // перевірка чи не натиснута клавіша Enter
    {
        goto l1;
    }
    if (go == 27) // перевірка чи натиснута клавіша Esc
    {
        goto ex;
    }
    else
    {
        goto l1;
    }
ex:
    system("pause");
}

void intr3()
{
l1:
    system("cls");
    char y[35];
    cout << "Введіть дату = ";
    cin >> y;
    int numb = 0;
    iin zap; // оголошуємо змінну для роботи із записом
    int space; // оголошуємо змінну, що є лічильником кількості записів на екрані
    int position = 0; // враховує к-сть виведених записів на сторінці
    int im = 0; // змінна для збереження коду натиснутої клавіші
    f.clear(); // очищуємо прапорці помилок
    f.seekp(position * countZinP * sizeof(struct iin), ios::beg); // переміщуємо вказівник на потрібний запис, що вираховується за наступною формулою
    position* countZinP * sizeof(struct iin);
    cout << ".___._______________.____________________._____________________.__________________.__________________.\n";
    cout << "| № | Дата доставки | Прізвище замовника |     Назва товару    | Кількість товару |  Назва доставки  |\n";
    cout << "|===|===============|====================|=====================|==================|==================|\n";
    space = 0; //обнуляємо значення лічильника кількості записів на екрані
    int a, b, c, a1, b1, c1;
    while ((!f.eof()) && (space < countZinP)) //умова виконання циклу: поки не досягли кінця файлу або кількість виведених записів на екран менше countZinP
    {
        f.read((char*)&zap, sizeof(struct iin)); //зчитування запису з файлу у змінну zap
        if (f.eof()) break; // якщо досягнуто кінець файлу, то вийти з циклу
        // виводимо поля зчитаного запису на екран
        if (fyy(y, zap.date) == 1)
        {
            printf("|%2d |  %.10s   | %13s      |  %17s  | %9d        | %14s|\n", ((1 + space) + ((position)*countZinP)), zap.date, zap.surname, zap.name, zap.nam, zap.delivery);
            numb = numb + zap.nam;
        }
        space++;
    }
    cout << "|___|_______________|____________________|_____________________|__________________|__________________|\n";
    printf(" Кількість доставленого товару на вказану дату: %7d \n", numb);
    cout << "\n Натисніть: \n\n Enter для того, щоб зробить перевірку заново. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
l2:
    int go = _getch(); //зчитуємо натиснуту клавішу
    if (go == 13) // перевірка чи не натиснута клавіша Enter
    {
        goto l1;
    }
    if (go == 27) // перевірка чи натиснута клавіша Esc
    {
        goto ex;
    }
    else
    {
        goto l2;
    }
ex:
    system("pause");
}

void intr4()
{
l1:
    system("cls");
    char y[35];
    cout << "Введіть назву товару = ";
    cin >> y;
    iin zap; // оголошуємо змінну для роботи із записом
    int space; // оголошуємо змінну, що є лічильником кількості записів на екрані
    int position = 0; // враховує к-сть виведених записів на сторінці
    int im = 0; // змінна для збереження коду натиснутої клавіші
    f.clear(); // очищуємо прапорці помилок
    f.seekp(position * countZinP * sizeof(struct iin), ios::beg); // переміщуємо вказівник на потрібний запис, що вираховується за наступною формулою
    position* countZinP * sizeof(struct iin);
    cout << ".___._______________.____________________._____________________.__________________.__________________.\n";
    cout << "| № | Дата доставки | Прізвище замовника |     Назва товару    | Кількість товару |  Назва доставки  |\n";
    cout << "|===|===============|====================|=====================|==================|==================|\n";
    space = 0; //обнуляємо значення лічильника кількості записів на екрані
    int a, b, c, a1, b1, c1;
    while ((!f.eof()) && (space < countZinP)) //умова виконання циклу: поки не досягли кінця файлу або кількість виведених записів на екран менше countZinP
    {
        f.read((char*)&zap, sizeof(struct iin)); //зчитування запису з файлу у змінну zap
        if (f.eof()) break; // якщо досягнуто кінець файлу, то вийти з циклу
        // виводимо поля зчитаного запису на екран
        if (fyy(y, zap.name) == 1)
        {
            printf("|%2d |  %.10s   | %13s      |  %17s  | %9d        | %14s|\n", ((1 + space) + ((position)*countZinP)), zap.date, zap.surname, zap.name, zap.nam, zap.delivery);
        }
        space++;
    }
    cout << "|___|_______________|____________________|_____________________|__________________|__________________|\n";
    cout << "\n Натисніть: \n\n Enter для того, щоб зробить перевірку заново. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
l2:
    int go = _getch(); //зчитуємо натиснуту клавішу
    if (go == 13) // перевірка чи не натиснута клавіша Enter
    {
        goto l1;
    }
    if (go == 27) // перевірка чи натиснута клавіша Esc
    {
        goto ex;
    }
    else
    {
        goto l2;
    }
ex:
    system("pause");
}

int stringToInt(const char* str, int startIndex, int length)
{
    int result = 0;
    int multiplier = 1;
    for (int i = startIndex + length - 1; i >= startIndex; --i)
    {
        result += (str[i] - '0') * multiplier;
        multiplier *= 10;
    }
    return result;
}

void intr5()
{
l1:
    system("cls");
    char y[35], x[35];
    cout << "Введіть дату доставки мін = ";
    cin >> y;
    cout << "Введіть дату доставки макс = ";
    cin >> x;
    iin zap; // оголошуємо змінну для роботи із записом
    int space; // оголошуємо змінну, що є лічильником кількості записів на екрані
    int position = 0; // враховує к-сть виведених записів на сторінці
    int im = 0; // змінна для збереження коду натиснутої клавіші
    f.clear(); // очищуємо прапорці помилок
    f.seekp(position * countZinP * sizeof(struct iin), ios::beg); // переміщуємо вказівник на потрібний запис, що вираховується за наступною формулою
    position* countZinP * sizeof(struct iin);
    cout << ".___._______________.____________________._____________________.__________________.__________________.\n";
    cout << "| № | Дата доставки | Прізвище замовника |     Назва товару    | Кількість товару |  Назва доставки  |\n";
    cout << "|===|===============|====================|=====================|==================|==================|\n";
    space = 0; //обнуляємо значення лічильника кількості записів на екрані
    int a, b, c, a1, b1, c1;
    while ((!f.eof()) && (space < countZinP)) //умова виконання циклу: поки не досягли кінця файлу або кількість виведених записів на екран менше countZinP
    {
        f.read((char*)&zap, sizeof(struct iin)); //зчитування запису з файлу у змінну zap
        if (f.eof()) break; // якщо досягнуто кінець файлу, то вийти з циклу
        // виводимо поля зчитаного запису на екран
        int day1 = stringToInt(x, 0, 2);
        int month1 = stringToInt(x, 3, 2);
        int year1 = stringToInt(x, 6, 4);

        int day2 = stringToInt(y, 0, 2);
        int month2 = stringToInt(y, 3, 2);
        int year2 = stringToInt(y, 6, 4);

        int day3 = stringToInt(zap.date, 0, 2);
        int month3 = stringToInt(zap.date, 3, 2);
        int year3 = stringToInt(zap.date, 6, 4);
        // Порівняння років
        if (year1 <= year3 && year3 <= year2)
        {
            // Порівняння місяців
            if (month1 <= month3 && month3 <= month2)
            {
                // Порівняння днів
                if (day1 <= day3 && day3 <= day2)
                    printf("|%2d |  %.10s   | %13s      |  %17s  | %9d        | %14s|\n", ((1 + space) + ((position)*countZinP)), zap.date, zap.surname, zap.name, zap.nam, zap.delivery);
            }
        }
        //if(zap.date>=y)
        //if(x>=zap.date)
        //printf("|%2d |  %.10s   | %13s      |  %17s  | %9d        | %14s|\n",((1+space)+((position)*countZinP)), zap.date,zap.surname,zap.name,zap.nam,zap.delivery);
        space++; //збільшуємо лічильник кількості записів на екрані на 1
    }
    cout << "|___|_______________|____________________|_____________________|__________________|__________________|\n";
    cout << "\n Натисніть: \n\n Enter для того, щоб зробить перевірку заново. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
l2:
    int go = _getch(); //зчитуємо натиснуту клавішу
    if (go == 13) // перевірка чи не натиснута клавіша Enter
    {
        goto l1;
    }
    if (go == 27) // перевірка чи натиснута клавіша Esc
    {
        goto ex;
    }
    else
    {
        goto l2;
    }
ex:
    system("pause");
}

void intr6()
{
l1:
    system("cls");
    int numb1 = 0, numb2 = 0;
    char x[10] = "Звичайна";
    char y[18] = "Експрес-доставка";
    iin zap; // оголошуємо змінну для роботи із записом
    int space; // оголошуємо змінну, що є лічильником кількості записів на екрані
    int position = 0; // враховує к-сть виведених записів на сторінці
    int im = 0; // змінна для збереження коду натиснутої клавіші
    f.clear(); // очищуємо прапорці помилок
    f.seekp(position * countZinP * sizeof(struct iin), ios::beg); // переміщуємо вказівник на потрібний запис, що вираховується за наступною формулою
    position* countZinP * sizeof(struct iin);
    space = 0; //обнуляємо значення лічильника кількості записів на екрані
    int a, b, c, a1, b1, c1;
    while ((!f.eof()) && (space < countZinP)) //умова виконання циклу: поки не досягли кінця файлу або кількість виведених записів на екран менше countZinP
    {
        f.read((char*)&zap, sizeof(struct iin)); //зчитування запису з файлу у змінну zap
        if (f.eof()) break; // якщо досягнуто кінець файлу, то вийти з циклу
        // виводимо поля зчитаного запису на екран
        if (fyy(y, zap.delivery) == 1)
        {
            numb2 = numb2 + zap.nam;
        }
        if (fyy(x, zap.delivery) == 1)
        {
            numb1 = numb1 + zap.nam;
        }
        space++;
    }
    printf(" Кількість доставленого товару звичайною доставкою: %7d \n", numb1);
    cout << endl;
    printf(" Кількість доставленого товару експрес-доставкою: %7d \n", numb2);
    cout << "\n Натисніть: \n\n Enter для того, щоб зробить перевірку заново. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
    int go = _getch(); //зчитуємо натиснуту клавішу
    if (go == 13) // перевірка чи не натиснута клавіша Enter
    {
        goto l1;
    }
    if (go == 27) // перевірка чи натиснута клавіша Esc
    {
        goto ex;
    }
    else
    {
        goto l1;
    }
ex:
    system("pause");
}

// *** Реалізація текстового інтерфейсу користувача ***
void menu()
{
    int im = 0, p = 0; //змінні для збереження кодів натиснутих клавіш при роботі з пунктами меню
    COORD crd, end; //оголошуємо змінні типу координат, що мають поле X та Y
    crd.X = 2; // задаємо початкову позицію курсору по осі Х для відображення знаку вибору
    crd.Y = 5; // задаємо початкову позицію курсору по осі Y для відображення знаку вибору
    end.X = 0; // задаємо позицію курсору по осі Х за межами меню
    end.Y = 15; // задаємо позицію курсору по осі Y за межами меню
start: // початок виведення меню на екран
    system("cls");
    cout << " |============================================================================|\n";
    cout << " |                     \"Довідник бюро доставки товарів\"                       |\n";
    cout << " |****************************************************************************|\n";
    cout << " | * Головне меню *                                                           |\n";
    cout << " |****************************************************************************|\n";
    cout << " | 1. Відкрити/створити файл                                                  |\n";
    cout << " | 2. Додати запис у файл                                                     |\n";
    cout << " | 3. Редагувати запис                                                        |\n";
    cout << " | 4. Видалити запис з файлу                                                  |\n";
    cout << " | 5. Вивести усю інформацію з файлу                                          |\n";
    cout << " | 6. Замовлення, кількість товару яких більше вказаного                      |\n";
    cout << " | 7. Замовлення, які здійснюються експрес-доставкою                          |\n";
    cout << " | 8. Загальна кількість доставленого товару на вказану дату                  |\n";
    cout << " | 9. Замовлення на вказаний товар                                            |\n";
    cout << " | 10. Товар, що був доставлений між вказаними датами                         |\n";
    cout << " | 11. Загальна кількість експрес-доставок та звичайних                       |\n";
    cout << " | 12. Вихiд                                                                  |\n";
    cout << " |============================================================================|\n";
    if (!f.is_open()) // в залежності від того чи відкрито файл даємо відповідне повідомлення
        cout << "\n Файл відсутній, завантажте або створіть файл. \n";
    else
        cout << "\n Файл успішно завантажено.: \"" << fdir << "\"\n";
    SetConsoleCursorPosition(hConsole, crd); // переводимо курсор в позицію координат crd
    SetConsoleTextAttribute(hConsole, (WORD)((20 << 0) | 10)); //задаємо колір шрифта та фону для виведення
    cout << ">>>";
    SetConsoleTextAttribute(hConsole, (WORD)((15 << 0) | 0)); //задаємо колір шрифта та фону для виведення
    SetConsoleCursorPosition(hConsole, end);//встановлюємо курсор у нижній лівий кут
    im = _getch(); //отримуємо код натиснутої клавіші
    switch (im)
    {
    case 72: // якщо натиснута клавіша "стрілка у гору" - Up
    {
        if (crd.Y > 5) crd.Y--; // якщо не досягнуто перший пункт меню, то зменшуємо значення координат crd.Y на 1 позицію
        goto start; // переходимо на мітку start
    }
    case 80: // якщо натиснута клавіша "стрілка вниз" - Down
    {
        if (crd.Y < 16) crd.Y++; // якщо не досягнуто останній пункт меню, то збільшуємо значення координат crd.Y на 1 позицію
        goto start; // переходимо на мітку start
    }
    case 13:
    {
        p = crd.Y + 45; // обраховуємо номер пункту меню, що буде в межах
        if ((!f.is_open()) && (p != 61)) p = 50; // якщо файл не відкрито, то буде здійснено перехід до пункту відкриття файлу
        switch (p)
        {
        case 50: // якщо обрано перший пукт меню
        {
            open_new(); // викликаємо функцію відкриття файл
            goto start; // переходимо на мітку start
        }
        case 51:
        {
            addzap(); // викликаємо функцію додавання записів у файл
            goto start;// переходимо на мітку start
        }
        case 52:
        {
            editzap(); // викликаємо функцію редагування записів у файл
            goto start;// переходимо на мітку start
        }
        case 53:
        {
            delzap(); // викликаємо функцію видалення запису з файлу
            goto start;// переходимо на мітку start
        }
        case 54:
        {
            all_out(); // викликаємо функцію виведення усіх записів з файлу
            goto start;// переходимо на мітку start
        }
        case 55:
        {
            intr1();
            goto start; // переходимо на мітку start
        }
        case 56:
        {
            intr2();
            goto start; // переходимо на мітку start
        }
        case 57:
        {
            intr3();
            goto start; // переходимо на мітку start
        }
        case 58:
        {
            intr4();
            goto start; // переходимо на мітку start
        }
        case 59:
        {
            intr5();
            goto start; // переходимо на мітку start
        }
        case 60:
        {
            intr6();
            goto start; // переходимо на мітку start
        }
        case 61:
        {
            exit_prog();// викликаємо функцію завершення виконання проєкту
            goto start; // переходимо на мітку start
        }
        default: goto start; // переходимо на мітку start
        }
    }
    default: goto start;
    }
}

//Головна функція
int main()
{
    SetConsoleCP(1251); //встановлюємо 1251 кодування для шрифту консолі
    SetConsoleOutputCP(1251);
    system("color 07"); //встановлюємо колір фону консолі чорним, а текст - білим
    menu(); // викликаємо процедуру menu
    system("pause");
    return 0;
}

